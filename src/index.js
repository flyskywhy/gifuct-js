import GIF from 'js-binary-schema-parser/lib/schemas/gif'
import { parse } from 'js-binary-schema-parser'
import { buildStream } from 'js-binary-schema-parser/lib/parsers/uint8'
import '@flyskywhy/react-native-browser-polyfill'
import { getPixel, setPixel } from '@rgba-image/pixel'
import { deinterlace } from './deinterlace'
import { lzw } from './lzw'

export const parseGIF = arrayBuffer => {
  const byteData = new Uint8Array(arrayBuffer)
  return parse(buildStream(byteData), GIF)
}

const generatePatch = image => {
  const totalPixels = image.pixels.length
  const patchData = new Uint8ClampedArray(totalPixels * 4)
  for (var i = 0; i < totalPixels; i++) {
    const pos = i * 4
    const colorIndex = image.pixels[i]
    const color = image.colorTable[colorIndex] || [0, 0, 0]
    patchData[pos] = color[0]
    patchData[pos + 1] = color[1]
    patchData[pos + 2] = color[2]
    patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0
  }

  return patchData
}

export const decompressFrame = (frame, gct, buildImagePatch) => {
  if (!frame.image) {
    console.warn('gif frame does not have associated image.')
    return
  }

  const { image } = frame

  // get the number of pixels
  const totalPixels = image.descriptor.width * image.descriptor.height
  // do lzw decompression
  var pixels = lzw(image.data.minCodeSize, image.data.blocks, totalPixels)

  // deal with interlacing if necessary
  if (image.descriptor.lct.interlaced) {
    pixels = deinterlace(pixels, image.descriptor.width)
  }

  const resultImage = {
    pixels: pixels,
    dims: {
      top: frame.image.descriptor.top,
      left: frame.image.descriptor.left,
      width: frame.image.descriptor.width,
      height: frame.image.descriptor.height
    }
  }

  // color table
  if (image.descriptor.lct && image.descriptor.lct.exists) {
    resultImage.colorTable = image.lct
  } else {
    resultImage.colorTable = gct
  }

  // add per frame relevant gce information
  if (frame.gce) {
    resultImage.delay = (frame.gce.delay || 10) * 10 // convert to ms
    resultImage.disposalType = frame.gce.extras.disposal
    // transparency
    if (frame.gce.extras.transparentColorGiven) {
      resultImage.transparentIndex = frame.gce.transparentColorIndex
    }
  }

  // create canvas usable imagedata if desired
  if (buildImagePatch) {
    resultImage.patch = generatePatch(resultImage)
  }

  return resultImage
}

const generateImageData = (parsedGif, resultImages) => {
  const {width, height} = parsedGif.lsd
  let gifNeedsDisposal = false

  for (let i = 0; i < resultImages.length; i++) {
    let resultImage = resultImages[i]
    if (width * height * 4 === resultImage.patch.length) {
      resultImage.imageData = new ImageData(resultImage.patch, width, height)
    } else if (i > 0) {
      let imageData = new ImageData(new Uint8ClampedArray(resultImages[i - 1].imageData.data), width, height)

      const left = resultImage.dims.left
      const top = resultImage.dims.top
      const dimsWidth = resultImage.dims.width
      const dimsHeight = resultImage.dims.height
      const patch = resultImage.patch
      let index

      if (gifNeedsDisposal) {
        for (let y = 0; y < dimsHeight; y++) {
          for (let x = 0; x < dimsWidth; x++) {
            setPixel(imageData, x + left, y + top, 0, 0, 0, 0)
          }
        }
        gifNeedsDisposal = false
      }

      for (let y = 0; y < dimsHeight; y++) {
        for (let x = 0; x < dimsWidth; x++) {
          index = (y * dimsWidth + x) * 4
          setPixel(imageData, x + left, y + top, patch[index], patch[index + 1], patch[index + 2], patch[index + 3])
        }
      }

      // ref to https://github.com/matt-way/gifuct-js/issues/35
      if (resultImage.disposalType === 2) {
        gifNeedsDisposal = true
      }

      resultImage.imageData = imageData
    }
  }
}

export const decompressFrames = (parsedGif, buildImagePatches, buildImageData) => {
  // in case gif file generated by https://products.aspose.app/imaging/animation-maker behavior:
  //     1st frame has gce but no image
  //     2nd frame has image but no gce
  const firstGce = parsedGif.frames.length ? parsedGif.frames[0].gce : undefined

  const resultImages = parsedGif.frames
    .filter(f => f.image)
    .map(f => decompressFrame({gce: firstGce, ...f}, parsedGif.gct, buildImagePatches))

  if (buildImagePatches && buildImageData) {
    generateImageData(parsedGif, resultImages)
  }

  return resultImages
}
